{"ast":null,"code":"import { defineComponent, useSlots, inject, ref, computed, nextTick, watch, reactive, toRefs, provide, onMounted, onBeforeUnmount, openBlock, createElementBlock, normalizeClass, unref, createVNode, withCtx, normalizeStyle, renderSlot, createTextVNode, toDisplayString, createCommentVNode, createElementVNode, Transition } from 'vue';\nimport AsyncValidator from 'async-validator';\nimport { castArray, clone } from 'lodash-unified';\nimport '../../../utils/index.mjs';\nimport '../../../tokens/index.mjs';\nimport '../../../hooks/index.mjs';\nimport { formItemProps } from './form-item.mjs';\nimport FormLabelWrap from './form-label-wrap.mjs';\nimport { formContextKey, formItemContextKey } from '../../../tokens/form.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nimport { useSize } from '../../../hooks/use-common-props/index.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { addUnit } from '../../../utils/vue/style.mjs';\nimport { isBoolean } from '@vueuse/core';\nimport { isString } from '@vue/shared';\nimport { getProp } from '../../../utils/objects.mjs';\nconst _hoisted_1 = [\"for\"];\nconst __default__ = {\n  name: \"ElFormItem\"\n};\n\nconst _sfc_main = /* @__PURE__ */defineComponent({ ...__default__,\n  props: formItemProps,\n\n  setup(__props, {\n    expose\n  }) {\n    const props = __props;\n    const COMPONENT_NAME = \"ElFormItem\";\n    const slots = useSlots();\n    const formContext = inject(formContextKey);\n    if (!formContext) throwError(COMPONENT_NAME, \"usage: <el-form><el-form-item /></el-form>\");\n    const parentFormItemContext = inject(formItemContextKey, void 0);\n\n    const _size = useSize(void 0, {\n      formItem: false\n    });\n\n    const ns = useNamespace(\"form-item\");\n    const validateState = ref(\"\");\n    const validateMessage = ref(\"\");\n    const formItemRef = ref();\n    let initialValue = void 0;\n    const labelStyle = computed(() => {\n      if (formContext.labelPosition === \"top\") {\n        return {};\n      }\n\n      const labelWidth = addUnit(props.labelWidth || formContext.labelWidth || \"\");\n      if (labelWidth) return {\n        width: labelWidth\n      };\n      return {};\n    });\n    const contentStyle = computed(() => {\n      if (formContext.labelPosition === \"top\" || formContext.inline) {\n        return {};\n      }\n\n      if (!props.label && !props.labelWidth && isNested) {\n        return {};\n      }\n\n      const labelWidth = addUnit(props.labelWidth || formContext.labelWidth || \"\");\n\n      if (!props.label && !slots.label) {\n        return {\n          marginLeft: labelWidth\n        };\n      }\n\n      return {};\n    });\n    const formItemClasses = computed(() => [ns.b(), ns.m(_size.value), ns.is(\"error\", validateState.value === \"error\"), ns.is(\"validating\", validateState.value === \"validating\"), ns.is(\"success\", validateState.value === \"success\"), ns.is(\"required\", isRequired.value || props.required), ns.is(\"no-asterisk\", formContext.hideRequiredAsterisk), {\n      [ns.m(\"feedback\")]: formContext.statusIcon\n    }]);\n\n    const _inlineMessage = computed(() => isBoolean(props.inlineMessage) ? props.inlineMessage : formContext.inlineMessage || false);\n\n    const validateClasses = computed(() => [ns.e(\"error\"), {\n      [ns.em(\"error\", \"inline\")]: _inlineMessage.value\n    }]);\n    const propString = computed(() => {\n      if (!props.prop) return \"\";\n      return isString(props.prop) ? props.prop : props.prop.join(\".\");\n    });\n    const labelFor = computed(() => props.for || propString.value);\n    const isNested = !!parentFormItemContext;\n    const fieldValue = computed(() => {\n      const model = formContext.model;\n\n      if (!model || !props.prop) {\n        return;\n      }\n\n      return getProp(model, props.prop).value;\n    });\n\n    const _rules = computed(() => {\n      const rules = props.rules ? castArray(props.rules) : [];\n      const formRules = formContext.rules;\n\n      if (formRules && props.prop) {\n        const _rules2 = getProp(formRules, props.prop).value;\n\n        if (_rules2) {\n          rules.push(...castArray(_rules2));\n        }\n      }\n\n      if (props.required !== void 0) {\n        rules.push({\n          required: !!props.required\n        });\n      }\n\n      return rules;\n    });\n\n    const validateEnabled = computed(() => _rules.value.length > 0);\n\n    const getFilteredRule = trigger => {\n      const rules = _rules.value;\n      return rules.filter(rule => {\n        if (!rule.trigger || !trigger) return true;\n\n        if (Array.isArray(rule.trigger)) {\n          return rule.trigger.includes(trigger);\n        } else {\n          return rule.trigger === trigger;\n        }\n      }).map(({\n        trigger: trigger2,\n        ...rule\n      }) => rule);\n    };\n\n    const isRequired = computed(() => _rules.value.some(rule => rule.required === true));\n    const shouldShowError = computed(() => validateState.value === \"error\" && props.showMessage && formContext.showMessage);\n    const currentLabel = computed(() => `${props.label || \"\"}${formContext.labelSuffix || \"\"}`);\n\n    const validate = async (trigger, callback) => {\n      if (callback) {\n        try {\n          validate(trigger);\n          callback(true);\n        } catch (err) {\n          callback(false, err);\n        }\n\n        validate(trigger).then(() => callback(true)).catch(fields => callback(false, fields));\n        return;\n      }\n\n      if (!validateEnabled.value) {\n        return;\n      }\n\n      const rules = getFilteredRule(trigger);\n\n      if (rules.length === 0) {\n        return;\n      }\n\n      validateState.value = \"validating\";\n      const descriptor = {\n        [propString.value]: rules\n      };\n      const validator = new AsyncValidator(descriptor);\n      const model = {\n        [propString.value]: fieldValue.value\n      };\n      return validator.validate(model, {\n        firstFields: true\n      }).then(() => void 0).catch(err => {\n        const {\n          errors,\n          fields\n        } = err;\n        if (!errors || !fields) console.error(err);\n        validateState.value = \"error\";\n        validateMessage.value = errors ? errors[0].message || `${props.prop} is required` : \"\";\n        formContext.emit(\"validate\", props.prop, !errors, validateMessage.value);\n        return Promise.reject(fields);\n      });\n    };\n\n    const clearValidate = () => {\n      validateState.value = \"\";\n      validateMessage.value = \"\";\n    };\n\n    const resetField = () => {\n      const model = formContext.model;\n      if (!model || !props.prop) return;\n      getProp(model, props.prop).value = initialValue;\n      nextTick(() => clearValidate());\n    };\n\n    watch(() => props.error, val => {\n      validateMessage.value = val || \"\";\n      validateState.value = val ? \"error\" : \"\";\n    }, {\n      immediate: true\n    });\n    watch(() => props.validateStatus, val => validateState.value = val || \"\");\n    const context = reactive({ ...toRefs(props),\n      $el: formItemRef,\n      size: _size,\n      validateState,\n      resetField,\n      clearValidate,\n      validate\n    });\n    provide(formItemContextKey, context);\n    onMounted(() => {\n      if (props.prop) {\n        formContext.addField(context);\n        initialValue = clone(fieldValue.value);\n      }\n    });\n    onBeforeUnmount(() => {\n      formContext.removeField(context);\n    });\n    expose({\n      size: _size,\n      validateMessage,\n      validate,\n      clearValidate,\n      resetField\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"formItemRef\",\n        ref: formItemRef,\n        class: normalizeClass(unref(formItemClasses))\n      }, [createVNode(unref(FormLabelWrap), {\n        \"is-auto-width\": unref(labelStyle).width === \"auto\",\n        \"update-all\": unref(formContext).labelWidth === \"auto\"\n      }, {\n        default: withCtx(() => [_ctx.label || _ctx.$slots.label ? (openBlock(), createElementBlock(\"label\", {\n          key: 0,\n          for: unref(labelFor),\n          class: normalizeClass(unref(ns).e(\"label\")),\n          style: normalizeStyle(unref(labelStyle))\n        }, [renderSlot(_ctx.$slots, \"label\", {\n          label: unref(currentLabel)\n        }, () => [createTextVNode(toDisplayString(unref(currentLabel)), 1)])], 14, _hoisted_1)) : createCommentVNode(\"v-if\", true)]),\n        _: 3\n      }, 8, [\"is-auto-width\", \"update-all\"]), createElementVNode(\"div\", {\n        class: normalizeClass(unref(ns).e(\"content\")),\n        style: normalizeStyle(unref(contentStyle))\n      }, [renderSlot(_ctx.$slots, \"default\"), createVNode(Transition, {\n        name: `${unref(ns).namespace.value}-zoom-in-top`\n      }, {\n        default: withCtx(() => [unref(shouldShowError) ? renderSlot(_ctx.$slots, \"error\", {\n          key: 0,\n          error: validateMessage.value\n        }, () => [createElementVNode(\"div\", {\n          class: normalizeClass(unref(validateClasses))\n        }, toDisplayString(validateMessage.value), 3)]) : createCommentVNode(\"v-if\", true)]),\n        _: 3\n      }, 8, [\"name\"])], 6)], 2);\n    };\n  }\n\n});\n\nexport { _sfc_main as default };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuEA;AAKA;AAEA;AACA,sBACAA;AACA;;AAEA;AAAAC;AAAA;;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;;AAGA;AACA;AAAAC;AAAA;AACA;AAAA,KAPA;AAUA;AACA;AACA;AAAA;;AAEA;AACA;AAAA;;AAEA;;AACA;AACA;AAAAC;AAAA;AAAA;;AAEA;AAAA,KAXA;AAcA,4CACAC,MADA,EAEAA,iBAFA,EAGAA,+CAHA,EAIAA,yDAJA,EAKAA,mDALA,EAMAA,qDANA,EAOAA,sDAPA,EAQA;AAAA;AAAA,KARA;;AAWA,0CACAC,iCACAC,mBADA,GAEAC,kCAHA;;AAMA,4CACAH,aADA,EAEA;AAAA;AAAA,KAFA;AAKA;AACA;AACA;AAAA,KAFA;AAKA;AAEA;AAEA;AACA;;AACA;AACA;AAAA;;AAEA;AAAA,KALA;;AAQA;AACA;AAEA;;AACA;AACA,gCACAI,SADA,EAEAF,UAFA,EAGAG,KAHA;;AAIA;AACAC;AAAA;AAAA;;AAIA;AACAA;AAAAC;AAAA;AAAA;;AAGA;AAAA,KAlBA;;AAqBA;;AAEA;AACA;AAEA,mBACAC,MADA,CACAC;AACA;;AACA;AACA;AACA,SAFA,MAEA;AACA;AAAA;AAAA,OANA,EAWAC,GAXA,CAWA;AAAAC;AAAA;AAAA,gBAXA;AAWA,KAdA;;AAkBA,sCACAC,iDADA;AAIA,qCACA,MACAC,mCACAX,iBADA,IAEAC,uBAJA;AAOA,kCACA,4DADA;;AAIA;AACA;AACA;AACAW;AACAC;AAAA,SAFA,CAEA,OACAC,GADA,EACA;AACAD;AAAA;;AAGAD,0BACAG,IADA,CACA,oBADA,EAEAC,KAFA,CAEAC,iCAFA;AAGA;AAAA;;AAGA;AACA;AAAA;;AAEA;;AACA;AACA;AAAA;;AAGAN;AAEA;AAAA,SACAO,gBADA,GACAd;AADA;AAGA;AACA;AACA;AADA;AASA,uBACAQ,QADA,CACAO,KADA,EACA;AAAAC;AAAA,OADA,EAEAL,IAFA,CAEA,YAFA,EAGAC,KAHA,CAGAF;AACA;AAAAO;AAAAJ;AAAA;AACA;AAEAN;AACAW,sCACA,qCACA,cADA,GACA,EAFA;AAGArB;AACA;AAAA,OAZA;AAYA,KAlDA;;AAsDA;AACAU;AACAW;AAAA,KAFA;;AAKA;AACA;AACA;AAEAC;AACAC;AAAA,KALA;;AAQAC,UACA,iBADA,EAEAC;AACAJ;AACAX;AAAA,KAJA,EAMA;AAAAgB;AAAA,KANA;AAQAF,UACA,0BADA,EAEAC,sCAFA;AAKA,kCACAE,aADA;AAEAC,sBAFA;AAGAC,iBAHA;AAIAnB,mBAJA;AAKAoB,gBALA;AAMAC,mBANA;AAOApB;AAPA;AASAqB;AAEAC;AACA;AACAjC;AACAkC;AAAA;AAAA,KAHA;AAMAC;AACAnC;AAAA,KADA;AAIAoC;AAEAP,iBAFA;AAIAR,qBAJA;AAMAV,cANA;AAQAoB,mBARA;AAUAD;AAVA","names":["throwError","formItem","width","marginLeft","ns","isBoolean","props","formContext","formRules","value","rules","required","filter","rule","map","trigger","_rules","validateState","validate","callback","err","then","catch","fields","propString","model","firstFields","errors","validateMessage","getProp","nextTick","watch","val","immediate","toRefs","$el","size","resetField","clearValidate","provide","onMounted","initialValue","onBeforeUnmount","expose"],"sources":["../../../../../../packages/components/form/src/form-item.vue"],"sourcesContent":["<template>\n  <div ref=\"formItemRef\" :class=\"formItemClasses\">\n    <form-label-wrap\n      :is-auto-width=\"labelStyle.width === 'auto'\"\n      :update-all=\"formContext.labelWidth === 'auto'\"\n    >\n      <label\n        v-if=\"label || $slots.label\"\n        :for=\"labelFor\"\n        :class=\"ns.e('label')\"\n        :style=\"labelStyle\"\n      >\n        <slot name=\"label\" :label=\"currentLabel\">\n          {{ currentLabel }}\n        </slot>\n      </label>\n    </form-label-wrap>\n\n    <div :class=\"ns.e('content')\" :style=\"contentStyle\">\n      <slot></slot>\n      <transition :name=\"`${ns.namespace.value}-zoom-in-top`\">\n        <slot v-if=\"shouldShowError\" name=\"error\" :error=\"validateMessage\">\n          <div :class=\"validateClasses\">\n            {{ validateMessage }}\n          </div>\n        </slot>\n      </transition>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  inject,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n  toRefs,\n  watch,\n  nextTick,\n  useSlots,\n} from 'vue'\nimport AsyncValidator from 'async-validator'\nimport { clone } from 'lodash-unified'\nimport {\n  addUnit,\n  ensureArray,\n  getProp,\n  isString,\n  isBoolean,\n  throwError,\n} from '@element-plus/utils'\nimport { formItemContextKey, formContextKey } from '@element-plus/tokens'\nimport { useSize, useNamespace } from '@element-plus/hooks'\nimport { formItemProps } from './form-item'\nimport FormLabelWrap from './form-label-wrap'\n\nimport type { CSSProperties } from 'vue'\nimport type {\n  RuleItem,\n  ValidateError,\n  ValidateFieldsError,\n} from 'async-validator'\nimport type { FormItemContext } from '@element-plus/tokens'\nimport type { Arrayable } from '@element-plus/utils'\nimport type { FormItemValidateState } from './form-item'\nimport type { FormItemRule } from './types'\n\nconst COMPONENT_NAME = 'ElFormItem'\ndefineOptions({\n  name: 'ElFormItem',\n})\nconst props = defineProps(formItemProps)\nconst slots = useSlots()\n\nconst formContext = inject(formContextKey)\nif (!formContext)\n  throwError(COMPONENT_NAME, 'usage: <el-form><el-form-item /></el-form>')\nconst parentFormItemContext = inject(formItemContextKey, undefined)\n\nconst _size = useSize(undefined, { formItem: false })\nconst ns = useNamespace('form-item')\n\nconst validateState = ref<FormItemValidateState>('')\nconst validateMessage = ref('')\nconst formItemRef = ref<HTMLDivElement>()\nlet initialValue: any = undefined\n\nconst labelStyle = computed<CSSProperties>(() => {\n  if (formContext.labelPosition === 'top') {\n    return {}\n  }\n\n  const labelWidth = addUnit(props.labelWidth || formContext.labelWidth || '')\n  if (labelWidth) return { width: labelWidth }\n  return {}\n})\n\nconst contentStyle = computed<CSSProperties>(() => {\n  if (formContext.labelPosition === 'top' || formContext.inline) {\n    return {}\n  }\n  if (!props.label && !props.labelWidth && isNested) {\n    return {}\n  }\n  const labelWidth = addUnit(props.labelWidth || formContext.labelWidth || '')\n  if (!props.label && !slots.label) {\n    return { marginLeft: labelWidth }\n  }\n  return {}\n})\n\nconst formItemClasses = computed(() => [\n  ns.b(),\n  ns.m(_size.value),\n  ns.is('error', validateState.value === 'error'),\n  ns.is('validating', validateState.value === 'validating'),\n  ns.is('success', validateState.value === 'success'),\n  ns.is('required', isRequired.value || props.required),\n  ns.is('no-asterisk', formContext.hideRequiredAsterisk),\n  { [ns.m('feedback')]: formContext.statusIcon },\n])\n\nconst _inlineMessage = computed(() =>\n  isBoolean(props.inlineMessage)\n    ? props.inlineMessage\n    : formContext.inlineMessage || false\n)\n\nconst validateClasses = computed(() => [\n  ns.e('error'),\n  { [ns.em('error', 'inline')]: _inlineMessage.value },\n])\n\nconst propString = computed(() => {\n  if (!props.prop) return ''\n  return isString(props.prop) ? props.prop : props.prop.join('.')\n})\n\nconst labelFor = computed(() => props.for || propString.value)\n\nconst isNested = !!parentFormItemContext\n\nconst fieldValue = computed(() => {\n  const model = formContext.model\n  if (!model || !props.prop) {\n    return\n  }\n  return getProp(model, props.prop).value\n})\n\nconst _rules = computed(() => {\n  const rules: FormItemRule[] = props.rules ? ensureArray(props.rules) : []\n\n  const formRules = formContext.rules\n  if (formRules && props.prop) {\n    const _rules = getProp<Arrayable<FormItemRule> | undefined>(\n      formRules,\n      props.prop\n    ).value\n    if (_rules) {\n      rules.push(...ensureArray(_rules))\n    }\n  }\n\n  if (props.required !== undefined) {\n    rules.push({ required: !!props.required })\n  }\n\n  return rules\n})\n\nconst validateEnabled = computed(() => _rules.value.length > 0)\n\nconst getFilteredRule = (trigger: string) => {\n  const rules = _rules.value\n  return (\n    rules\n      .filter((rule) => {\n        if (!rule.trigger || !trigger) return true\n        if (Array.isArray(rule.trigger)) {\n          return rule.trigger.includes(trigger)\n        } else {\n          return rule.trigger === trigger\n        }\n      })\n      // exclude trigger\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      .map(({ trigger, ...rule }): RuleItem => rule)\n  )\n}\n\nconst isRequired = computed(() =>\n  _rules.value.some((rule) => rule.required === true)\n)\n\nconst shouldShowError = computed(\n  () =>\n    validateState.value === 'error' &&\n    props.showMessage &&\n    formContext.showMessage\n)\n\nconst currentLabel = computed(\n  () => `${props.label || ''}${formContext.labelSuffix || ''}`\n)\n\nconst validate: FormItemContext['validate'] = async (trigger, callback) => {\n  if (callback) {\n    try {\n      validate(trigger)\n      callback(true)\n    } catch (err) {\n      callback(false, err as ValidateFieldsError)\n    }\n\n    validate(trigger)\n      .then(() => callback(true))\n      .catch((fields: ValidateFieldsError) => callback(false, fields))\n    return\n  }\n\n  if (!validateEnabled.value) {\n    return\n  }\n  const rules = getFilteredRule(trigger)\n  if (rules.length === 0) {\n    return\n  }\n\n  validateState.value = 'validating'\n\n  const descriptor = {\n    [propString.value]: rules,\n  }\n  const validator = new AsyncValidator(descriptor)\n  const model = {\n    [propString.value]: fieldValue.value,\n  }\n\n  interface ValidateFailure {\n    errors: ValidateError[] | null\n    fields: ValidateFieldsError\n  }\n\n  return validator\n    .validate(model, { firstFields: true })\n    .then(() => undefined)\n    .catch((err: ValidateFailure) => {\n      const { errors, fields } = err\n      if (!errors || !fields) console.error(err)\n\n      validateState.value = 'error'\n      validateMessage.value = errors\n        ? errors[0].message || `${props.prop} is required`\n        : ''\n      formContext.emit('validate', props.prop!, !errors, validateMessage.value)\n      return Promise.reject(fields)\n    })\n}\n\nconst clearValidate: FormItemContext['clearValidate'] = () => {\n  validateState.value = ''\n  validateMessage.value = ''\n}\n\nconst resetField: FormItemContext['resetField'] = () => {\n  const model = formContext.model\n  if (!model || !props.prop) return\n\n  getProp(model, props.prop).value = initialValue\n  nextTick(() => clearValidate())\n}\n\nwatch(\n  () => props.error,\n  (val) => {\n    validateMessage.value = val || ''\n    validateState.value = val ? 'error' : ''\n  },\n  { immediate: true }\n)\nwatch(\n  () => props.validateStatus,\n  (val) => (validateState.value = val || '')\n)\n\nconst context: FormItemContext = reactive({\n  ...toRefs(props),\n  $el: formItemRef,\n  size: _size,\n  validateState,\n  resetField,\n  clearValidate,\n  validate,\n})\nprovide(formItemContextKey, context)\n\nonMounted(() => {\n  if (props.prop) {\n    formContext.addField(context)\n    initialValue = clone(fieldValue.value)\n  }\n})\nonBeforeUnmount(() => {\n  formContext.removeField(context)\n})\n\ndefineExpose({\n  /** @description form item size */\n  size: _size,\n  /** @description validation message */\n  validateMessage,\n  /** @description validate form item */\n  validate,\n  /** @description clear validation status */\n  clearValidate,\n  /** @description reset field value */\n  resetField,\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}